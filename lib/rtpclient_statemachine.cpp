// This is an autogenerated file. It should be included at source
/** STATE MACHINE
 * ```mermaid
 * stateDiagram
 *     WaitToStart --> PrepareNextDNS: Started
 *     PrepareNextDNS --> ResolveNextIpPort: NextReady
 *     PrepareNextDNS --> Error: ResolveListExhausted
 *     ResolveNextIpPort --> PrepareNextDNS: ConnectListExhausted
 *     ResolveNextIpPort --> ResolveNextIpPort: ResolveFailed
 *     ResolveNextIpPort --> ConnectControl: Resolved
 *     ConnectControl --> ResolveNextIpPort: ConnectFailed
 *     ConnectControl --> ConnectMidi: Connected
 *     ConnectMidi --> AllConnected: Connected
 *     ConnectMidi --> DisconnectControl: ConnectFailed
 *     DisconnectControl --> ResolveNextIpPort: ConnectFailed
 * 
 *     AllConnected --> SendCkShort: SendCK
 * 
 *     # the ck sends 6 short packets (wait only 2 seconds), and then long ones (60 seconds).
 *     SendCkShort --> WaitSendCkShort: WaitSendCK (*6)
 *     SendCkShort --> WaitSendCkLong: LatencyMeasured
 *     SendCkShort --> DisconnectBecauseCKTimeout: Timeout
 * 
 *     WaitSendCkShort --> SendCkShort: SendCK
 * 
 *     SendCkLong --> WaitSendCkLong: WaitSendCK
 *     SendCkLong --> DisconnectBecauseCKTimeout: Timeout
 *     WaitSendCkLong --> SendCkLong: SendCK
 * 
 *     DisconnectBecauseCKTimeout --> ConnectControl: ConnectFailed
 * 
 *     Error --> TryConnectToAllKnownDNS: Connect
 *     TryConnectToAllKnownDNS --> PrepareNextDNS: Connect
 * 
 * ```
 */
void rtpclient_t::handle_event(event_e event){
    state_e oldstate = state;
    state = state_e::Error;
    switch(oldstate){
        case state_e::Error:
            switch(event){
                case event_e::Connect:
                    state = state_e::TryConnectToAllKnownDNS;
                    break;
            default:;
            }
            break;
        case state_e::WaitToStart:
            switch(event){
                case event_e::Started:
                    state = state_e::PrepareNextDNS;
                    break;
            default:;
            }
            break;
        case state_e::PrepareNextDNS:
            switch(event){
                case event_e::NextReady:
                    state = state_e::ResolveNextIpPort;
                    break;
                case event_e::ResolveListExhausted:
                    state = state_e::Error;
                    break;
            default:;
            }
            break;
        case state_e::ResolveNextIpPort:
            switch(event){
                case event_e::ConnectListExhausted:
                    state = state_e::PrepareNextDNS;
                    break;
                case event_e::ResolveFailed:
                    state = state_e::ResolveNextIpPort;
                    break;
                case event_e::Resolved:
                    state = state_e::ConnectControl;
                    break;
            default:;
            }
            break;
        case state_e::ConnectControl:
            switch(event){
                case event_e::ConnectFailed:
                    state = state_e::ResolveNextIpPort;
                    break;
                case event_e::Connected:
                    state = state_e::ConnectMidi;
                    break;
            default:;
            }
            break;
        case state_e::ConnectMidi:
            switch(event){
                case event_e::Connected:
                    state = state_e::AllConnected;
                    break;
                case event_e::ConnectFailed:
                    state = state_e::DisconnectControl;
                    break;
            default:;
            }
            break;
        case state_e::AllConnected:
            switch(event){
                case event_e::SendCK:
                    state = state_e::SendCkShort;
                    break;
            default:;
            }
            break;
        case state_e::DisconnectControl:
            switch(event){
                case event_e::ConnectFailed:
                    state = state_e::ResolveNextIpPort;
                    break;
            default:;
            }
            break;
        case state_e::SendCkShort:
            switch(event){
                case event_e::WaitSendCK:
                    state = state_e::WaitSendCkShort;
                    break;
                case event_e::LatencyMeasured:
                    state = state_e::WaitSendCkLong;
                    break;
                case event_e::Timeout:
                    state = state_e::DisconnectBecauseCKTimeout;
                    break;
            default:;
            }
            break;
        case state_e::WaitSendCkShort:
            switch(event){
                case event_e::SendCK:
                    state = state_e::SendCkShort;
                    break;
            default:;
            }
            break;
        case state_e::WaitSendCkLong:
            switch(event){
                case event_e::SendCK:
                    state = state_e::SendCkLong;
                    break;
            default:;
            }
            break;
        case state_e::DisconnectBecauseCKTimeout:
            switch(event){
                case event_e::ConnectFailed:
                    state = state_e::ConnectControl;
                    break;
            default:;
            }
            break;
        case state_e::SendCkLong:
            switch(event){
                case event_e::WaitSendCK:
                    state = state_e::WaitSendCkLong;
                    break;
                case event_e::Timeout:
                    state = state_e::DisconnectBecauseCKTimeout;
                    break;
            default:;
            }
            break;
        case state_e::TryConnectToAllKnownDNS:
            switch(event){
                case event_e::Connect:
                    state = state_e::PrepareNextDNS;
                    break;
            default:;
            }
            break;
    }
    switch(state){
        case state_e::Error:
            DEBUG("Error, previous state: {}", oldstate);
            state_error();
            break;
        case state_e::WaitToStart:
            state_wait_to_start();
            break;
        case state_e::PrepareNextDNS:
            state_prepare_next_dns();
            break;
        case state_e::ResolveNextIpPort:
            state_resolve_next_ip_port();
            break;
        case state_e::ConnectControl:
            state_connect_control();
            break;
        case state_e::ConnectMidi:
            state_connect_midi();
            break;
        case state_e::AllConnected:
            state_all_connected();
            break;
        case state_e::DisconnectControl:
            state_disconnect_control();
            break;
        case state_e::SendCkShort:
            state_send_ck_short();
            break;
        case state_e::WaitSendCkShort:
            state_wait_send_ck_short();
            break;
        case state_e::WaitSendCkLong:
            state_wait_send_ck_long();
            break;
        case state_e::DisconnectBecauseCKTimeout:
            state_disconnect_because_cktimeout();
            break;
        case state_e::SendCkLong:
            state_send_ck_long();
            break;
        case state_e::TryConnectToAllKnownDNS:
            state_try_connect_to_all_known_dns();
            break;
    }
}
// event formatter
const char *rtpclient_t::to_string(rtpclient_t::event_e value) {
    switch (value) {
    case rtpclient_t::event_e::Started:
        return "Started";
    case rtpclient_t::event_e::NextReady:
        return "NextReady";
    case rtpclient_t::event_e::ResolveListExhausted:
        return "ResolveListExhausted";
    case rtpclient_t::event_e::ConnectListExhausted:
        return "ConnectListExhausted";
    case rtpclient_t::event_e::ResolveFailed:
        return "ResolveFailed";
    case rtpclient_t::event_e::Resolved:
        return "Resolved";
    case rtpclient_t::event_e::ConnectFailed:
        return "ConnectFailed";
    case rtpclient_t::event_e::Connected:
        return "Connected";
    case rtpclient_t::event_e::SendCK:
        return "SendCK";
    case rtpclient_t::event_e::WaitSendCK:
        return "WaitSendCK";
    case rtpclient_t::event_e::LatencyMeasured:
        return "LatencyMeasured";
    case rtpclient_t::event_e::Timeout:
        return "Timeout";
    case rtpclient_t::event_e::Connect:
        return "Connect";
    default:
            return "unknown";
    }  
}
// state formatter
const char *rtpclient_t::to_string(rtpclient_t::state_e value) {
    switch (value) {
    case rtpclient_t::state_e::Error:
        return  "Error";
    case rtpclient_t::state_e::WaitToStart:
        return  "WaitToStart";
    case rtpclient_t::state_e::PrepareNextDNS:
        return  "PrepareNextDNS";
    case rtpclient_t::state_e::ResolveNextIpPort:
        return  "ResolveNextIpPort";
    case rtpclient_t::state_e::ConnectControl:
        return  "ConnectControl";
    case rtpclient_t::state_e::ConnectMidi:
        return  "ConnectMidi";
    case rtpclient_t::state_e::AllConnected:
        return  "AllConnected";
    case rtpclient_t::state_e::DisconnectControl:
        return  "DisconnectControl";
    case rtpclient_t::state_e::SendCkShort:
        return  "SendCkShort";
    case rtpclient_t::state_e::WaitSendCkShort:
        return  "WaitSendCkShort";
    case rtpclient_t::state_e::WaitSendCkLong:
        return  "WaitSendCkLong";
    case rtpclient_t::state_e::DisconnectBecauseCKTimeout:
        return  "DisconnectBecauseCKTimeout";
    case rtpclient_t::state_e::SendCkLong:
        return  "SendCkLong";
    case rtpclient_t::state_e::TryConnectToAllKnownDNS:
        return  "TryConnectToAllKnownDNS";
    default:        return  "unknown";
    }
}
